{"version":3,"file":"callToPop.js","sourceRoot":"","sources":["../../../../../src/private/core/requestPerSecondLimit/callToPop.ts"],"names":[],"mappings":";;;AAEA,wCAA4C;AAC5C,uCAAuC;AAEvC,yDAAyD;AACzD,wBAAwB;AACxB,SAAgB,uBAAuB;IAAvC,iBA+BC;IA9BC,IAAI,WAAW,GAAG,KAAK,CAAC;IACxB,IAAM,KAAK,GAAW,CAAC,CAAC;IAExB,uCAAuC;IACvC,IAAM,YAAY,GAAG,UAAM,EAAsB;QAC/C,IAAM,SAAS,GAA0C,EAAE,CAAC;QAC5D,IAAM,iBAAiB,GAAG;;;;gBACxB,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;oBACzC,WAAW,GAAG,IAAI,CAAC;oBACb,aAAa,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC;oBAC5C,IAAI,aAAa,KAAK,SAAS,EAAE;wBACzB,KAAA,eAAe,aAAa,IAAA,EAA3B,IAAI,QAAA,EAAE,IAAI,QAAA,CAAkB;wBAEnC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;qBACpB;oBACD,UAAU,CAAC;;;;oCACT,WAAW,GAAG,KAAK,CAAC;oCACpB,qBAAM,iBAAiB,EAAE,EAAA;;oCAAzB,SAAyB,CAAC;;;;yBAC3B,EAAE,kBAAU,CAAC,KAAK,CAAC,CAAC,CAAC;iBACvB;gBACD,sBAAO,KAAK,CAAC,EAAC;;aACf,CAAC;QAEF,+CAA+C;QAC/C,OAAO,SAAe,aAAa,CAAC,EAAiB;;;oBACnD,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;oBACzB,sBAAO,iBAAiB,EAAE,EAAC;;;SAC5B,CAAC;IACJ,CAAC,CAAC;IACF,OAAO,YAAY,CAAC;AACtB,CAAC;AA/BD,0DA+BC;AAED,IAAM,UAAU,GAAG,UAAQ,SAAmC;IAC5D,OAAA,SAAS,CAAC,KAAK,EAAE;AAAjB,CAAiB,CAAC;AAEpB,EAAE;AACF,EAAE;AACF,2BAA2B;AAC3B,wBAAwB;AACxB,sDAAsD;AACtD,4CAA4C;AAC5C,0BAA0B;AAC1B,wDAAwD;AACxD,sEAAsE;AACtE,oDAAoD;AACpD,OAAO;AACP,IAAI;AAEJ,iFAAiF;AACjF,+CAA+C;AAC/C,uBAAuB;AACvB,oCAAoC;AACpC,0BAA0B;AAC1B,2BAA2B;AAC3B,6BAA6B;AAC7B,sCAAsC;AACtC,0DAA0D;AAC1D,0BAA0B;AAC1B,MAAM;AACN,KAAK;AAEL,oEAAoE;AACpE,mCAAmC;AACnC,mDAAmD;AACnD,kCAAkC;AAClC,uBAAuB;AACvB,KAAK;AAEL,oCAAoC;AACpC,aAAa;AACb,qBAAqB;AACrB,wEAAwE;AACxE,OAAO;AACP,KAAK;AACL,+DAA+D;AAC/D,mCAAmC;AACnC,qBAAqB;AACrB,wEAAwE;AACxE,OAAO;AACP,KAAK;AACL,8CAA8C;AAC9C,gBAAgB","sourcesContent":["// tslint:disable no-any\nimport { CallBack } from '../../../typescript';\nimport { perSeconds } from '../../../utils';\n// tslint:disable: prefer-array-literal\n\n// create the function required to have a request limiter\n// set the initial state\nexport function myRequestLimiterFactory() {\n  let isRequested = false;\n  const hertz: number = 1;\n\n  // the request limiter function  itself\n  const queueLimiter = <Tfn>(fn: () => Promise<Tfn>) => {\n    const queueList: [() => Promise<Tfn>, CallBack<any>][] = [];\n    const shiftOutFromQueue = async () => {\n      if (queueList.length >= 1 && !isRequested) {\n        isRequested = true;\n        const nextToExecute = shiftQueue(queueList);\n        if (nextToExecute !== undefined) {\n          const [myfn, mycb] = nextToExecute;\n\n          mycb(null, myfn());\n        }\n        setTimeout(async () => {\n          isRequested = false;\n          await shiftOutFromQueue();\n        }, perSeconds(hertz));\n      }\n      return void 0;\n    };\n\n    // when isRequested = true or if queue is empty\n    return async function pushInToQueue(cb: CallBack<any>): Promise<void> {\n      queueList.push([fn, cb]);\n      return shiftOutFromQueue();\n    };\n  };\n  return queueLimiter;\n}\n\nconst shiftQueue = <TFnct>(queueList: [TFnct, CallBack<any>][]) =>\n  queueList.shift();\n\n//\n//\n// const hertz: number = 1;\n// let isCalled = false;\n// const callsQueue: Array<[Function, CallBack]> = [];\n// export function requestLimiterFactory() {\n//   let isCalled = false;\n//   const callsQueue: Array<[Function, CallBack]> = [];\n//   return function requestLimiter(fn: Function, hertz: number = 1) {\n//     return addToQueue(callsQueue)(callToPop)(fn);\n//   };\n// }\n\n// const callToPop = () => ({ isCalled }: { isCalled: boolean }) => async () => {\n//   if (callsQueue.length >= 1 && !isCalled) {\n//     isCalled = true;\n//     setTimeout(async function() {\n//       isCalled = false;\n//       await callToPop();\n//     }, perSeconds(hertz));\n//     const poped = callsQueue.pop();\n//     const [myfn, mycb] = !!poped ? poped : neverWillBe;\n//     mycb(null, myfn());\n//   }\n// };\n\n// const addToQueue = (callsQueue: Array<[Function, CallBack]>) => (\n//   callToPop: () => Promise<void>\n// ) => (fn: Function) => async (cb: CallBack) => {\n//   callsQueue.unshift([fn, cb]);\n//   await callToPop();\n// };\n\n// const neverWillCb = async () => {\n//   void0();\n//   throw new Error(\n//     'NEVER: lenght is validated prior to pop this should never occur'\n//   );\n// };\n// const neverCb = (error: Error | null, returnValue: any) => {\n//   void0({ returnValue, error });\n//   throw new Error(\n//     'NEVER: lenght is validated prior to pop this should never occur'\n//   );\n// };\n// const neverWillBe = [neverWillCb, neverCb];\n// void0(void0);\n"]}